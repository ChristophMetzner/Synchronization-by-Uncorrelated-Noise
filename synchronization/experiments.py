import glob
import pickle
import numpy as np
import os

from synchronization import constants
from synchronization import runner

from itertools import product
from mopet import mopet

class Experiment:
    """ Base Experiment."""

    name = "name"

    def run(self):
        raise NotImplementedError()

    @classmethod
    def load(cls, condition=lambda x: True) -> [dict]:
        models = []
        base_path = f"{constants.MODELS_PATH}/{cls.name}"
        for file in glob.glob(f"{base_path}/*.pkl"):
            with open(file, "rb") as f:
                model = pickle.load(f)
                if condition(model):
                    models.append(model)
        return models

    @classmethod
    def clean(cls):
        print(f"Start cleaning models of experiment {cls.name}")

        base_path = f"{constants.MODELS_PATH}/{cls.name}"
        for file in glob.glob(f"{base_path}/*.pkl"):
            print(f"Remove file {file}")
            os.remove(file)

        print("Finished cleaning.")


class NoiseExperiment(Experiment):
    """
    Simulates models for the "effect of noise in a single population" experiment.

    All combinations over a range of different noise parameters.

    Input Variables
        1. Mean
        2. Sigma
        3. Tau
    """

    name = "noise"

    def __init__(
        self,
        mean_range: np.ndarray = None,
        sigma_range: np.array = None,
        tau_range: np.array = None,
    ):
        mean = mean_range if mean_range else np.arange(0, 10, 0.5)
        sigma = sigma_range if sigma_range else np.arange(0, 6, 0.5)
        tau = tau_range if tau_range else np.arange(1, 60, 5)

        self._param_space = list(product(mean, sigma, tau))

    def run(self):
        total = len(self._param_space)
        print(f"Starting simulation of {total} parameter configurations ...")

        for idx, vals in enumerate(self._param_space):
            (m, s, t) = vals
            print(
                f"{idx + 1} of {total} Running parameter configuration: {m} - {s} - {t}"
            )

            config = dict()
            config["runtime"] = 1000

            config["ou_mu"] = {"ou_mean": m, "ou_sigma": s, "ou_tau": t}

            config["ou_sigma"] = {
                "ou_X0": 0.0,
                "ou_mean": 0.0,
                "ou_sigma": 0.2,
                "ou_tau": 1,
            }

            runner.run(
                f"{m}-{s}-{t}", experiment_name=self.name, modified_params=config
            )


class CouplingStrengthExperiment(Experiment):
    name = "coupling"

    def __init__(self):
        e_to_i = np.arange(0.1, 0.6, 0.1)
        # e_to_e = np.arange(0.05, 0.2, 0.02)
        self._param_space = e_to_i

    def run(self):
        print(
            f"Starting simulation of {len(self._param_space)} parameter configurations ..."
        )
        # TODO: product of multiple parameters
        for idx, param in enumerate(self._param_space):
            print(
                f"{idx + 1} of {len(self._param_space)} Running parameter configuration: {param}"
            )
            runner.run(
                f"{param}", experiment_name=self.name, modified_params={"J_etoi": param}
            )

        print("Finished simulation.")


class IndependentNoiseOn2CoupledNetworks(Experiment):

    name = "ind_noise_coupled_network"

    def __init__(self):
        self._strengths = np.arange(0.2, 2, 0.3)

    def run(self):
        print("Cleaning previous run ...")
        self.clean()

        print("Starting with new run ...")
        param_count = self._strengths
        for idx, param in enumerate(self._strengths):

            params = {
                # synaptic coupling strengths, most important parameters for tuning PING mechanism
                "J_itoi": 5.0,
                "J_etoe": 0.9,
                "J_etoi": 3.0,
                "J_itoe": 5.0,
                # Independent spike trains generated by Poisson Point Process for each target neuron
                "ext_input_type": "poisson",
                "poisson_strengths": [param, 0.5],
                # noise frequency ration between networks
                "poisson_p": 1.0,
                # 50 Hz rate as in Meng et. al. and decreasing with network index
                "poisson_rates": [30, 50],
                "poisson_size": 30,
                # mu = 200^-1
                "poisson_mean_input": 0.005,
                "J_ppee": 0.1,
                # increase from 0.1 to 0.2 increases mainly amplitude
                "J_ppei": 0.1,
                # if set to default of 0.1 this leads to strange split in frequency band
                "const_delay": 0.2,
                "N_pop": 2,
            }

            print(
                f"{idx + 1} of {param_count} Running parameter configuration: {param} ..."
            )

            runner.run(
                f"{param}", experiment_name=self.name, modified_params=params,
            )

        print("Finished simulation.")


class MopetExampleExperiment:
    def run(self):
        params = {"J_etoe": np.arange(1, 3, 1)}

        ex = mopet.Exploration(run_network, params)
        ex.run()
        ex.load_results()

        print(ex.results)
        print(ex.df)


def run_network(params) -> dict:
    """
    Wrapper run method for Mopet.

    :param params:
    :return: dict
    """
    model = runner.run(modified_params=params)
    return {
        "r_e": model["model_results"]["net"]["r_e"],
        "r_i1": model["model_results"]["net"]["r_i1"],
    }